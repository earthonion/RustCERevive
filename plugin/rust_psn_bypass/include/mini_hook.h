#pragma once
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Orbis / GoldHEN helpers you already have
#include "plugin_common.h"
#include "patch.h"
#include "hde/hde64.h"

// ---- Configuration ---------------------------------------------------------
#ifndef MH_MAX_PROLOGUE
#define MH_MAX_PROLOGUE 32     // enough to cover our 14B abs jmp
#endif

// ---- Types -----------------------------------------------------------------
typedef enum { MH_MODE_NONE=0, MH_MODE_THUNK=1, MH_MODE_WRAPPER=2 } mh_mode_t;

typedef struct mh_hook_t {
    uint64_t target_addr;
    void*    user_impl;       // your C callback
    void*    user_thunk;      // optional thunk entry (NULL => wrapper mode)
    void*    thunk_slot;      // address of the thunk's slot symbol (only for thunk mode)
    void*    tramp_mem;       // allocated trampoline
    size_t   tramp_size;
    void*    orig_fn;         // points to trampoline (call this to reach original)
    size_t   stolen_len;
    uint8_t  original[MH_MAX_PROLOGUE];
    int      installed;
    mh_mode_t mode;
} mh_hook_t;

// ---- API -------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif
/**
 * Compute a safe instruction boundary near `addr` that covers at least min_size.
 * Uses HDE64; returns the total size (0 on failure).
 */
size_t mh_calc_prologue_len(uintptr_t addr, size_t min_size);

/**
 * Install a hook:
 *   - `hook->target_addr` must be set before calling
 *   - `hook->user_thunk`  is your asm bridge (generated by macro below)
 *   - `hook->user_impl`   is your C callback called by the thunk
 *
 * On success:
 *   - `hook->orig_fn` points at the trampoline (cast to your typedef)
 *   - `hook->installed` = true
 */
int mh_install(mh_hook_t *hook);

/**
 * Remove a previously installed hook (restores original bytes, unmaps tramp).
 */
int mh_remove(mh_hook_t *hook);

// ---- Utils -----------------------------------------------------------------
void mh_log(const char *fmt, ...);
void mh_bind_thunk_slot(void **slot_addr, void *trampoline);

#ifdef __cplusplus
}
#endif

// ---- Thunk generator --------------------------------------------------------
/**
 * Define a per-hook thunk + storage symbol (RIP-addressable) in one shot.
 *
 * IMPORTANT: This thunk preserves the return value in %rax and restores all
 * volatile registers. However, depending on your specific use case, you may
 * need to modify this thunk to handle:
 *   - Floating point arguments/return values (XMM registers)
 *   - Different calling conventions
 *   - Additional registers that need preservation
 *   - Stack alignment requirements
 *
 * If your hook doesn't work correctly even with a minimal pass-through,
 * check if the target function uses registers or conventions not handled here.
 *
 * Example:
 *   // 1) Define your typed original and callback signature
 *   typedef long (*playback_t)(long, char*, int, int);
 *   long my_callback(long a, char *cmd, int b, int sz);
 *
 *   // 2) Create a hook object and a thunk bound to it
 *   static mh_hook_t g_pb_hook = {0};
 *   MH_DEFINE_THUNK(pb, my_callback)
 *
 *   // 3) When installing:
 *   g_pb_hook.user_impl = (void*)my_callback;
 *   g_pb_hook.user_thunk = (void*)MH_THUNK_ENTRY(pb);
 *   // after mh_install(&g_pb_hook), cast:
 *   playback_t original = (playback_t)g_pb_hook.orig_fn;
 *
 */
#define MH_STR1(x) #x
#define MH_STR(x)  MH_STR1(x)

#define MH_THUNK_LABEL(name)      __mh_thunk_##name
#define MH_TRAMP_SLOT(name)       __mh_tramp_slot_##name
#define MH_THUNK_ENTRY(name)      MH_THUNK_LABEL(name)

#ifdef __GNUC__
#define MH_DEFINE_THUNK(name, cb_fn)                           \
    __attribute__((used)) void *MH_TRAMP_SLOT(name) = 0;               \
    __attribute__((naked)) void MH_THUNK_LABEL(name)(void) {           \
        __asm__ volatile(                                              \
            /* Prologue + spill volatile integer regs to stack */               \
            "push %rbp\n"                                                       \
            "mov  %rsp, %rbp\n"                                                 \
            /* Reserve 0x130 bytes for all saved state */                       \
            "sub  $0x130, %rsp\n"                                               \
            /* Save callee-saved registers FIRST (before calling callback) */   \
            "mov  %rbx, -0x50(%rbp)\n"  /* save rbx (callee-saved) */          \
            "mov  %r12, -0x58(%rbp)\n"  /* save r12 (callee-saved) */          \
            "mov  %r13, -0x60(%rbp)\n"  /* save r13 (callee-saved) */          \
            "mov  %r14, -0x68(%rbp)\n"  /* save r14 (callee-saved) */          \
            "mov  %r15, -0x70(%rbp)\n"  /* save r15 (callee-saved) */          \
            /* Save volatile argument registers */                              \
            "mov  %rdi, -0x08(%rbp)\n"  /* save rdi */                          \
            "mov  %rsi, -0x10(%rbp)\n"  /* save rsi */                          \
            "mov  %rdx, -0x18(%rbp)\n"  /* save rdx */                          \
            "mov  %rcx, -0x20(%rbp)\n"  /* save rcx */                          \
            "mov  %r8,  -0x28(%rbp)\n"  /* save r8  */                          \
            "mov  %r9,  -0x30(%rbp)\n"  /* save r9  */                          \
            "mov  %r10, -0x38(%rbp)\n"  /* save r10 */                          \
            "mov  %r11, -0x40(%rbp)\n"  /* save r11 */                          \
            /* Save AL register (contains # of XMM args) as part of RAX */      \
            "mov  %rax, -0x48(%rbp)\n"  /* save rax (includes AL) */            \
            /* Save XMM0-XMM7 (floating-point/vector argument registers) */     \
            "movdqu %xmm0, -0x90(%rbp)\n"  /* save xmm0 */                      \
            "movdqu %xmm1, -0xa0(%rbp)\n"  /* save xmm1 */                      \
            "movdqu %xmm2, -0xb0(%rbp)\n"  /* save xmm2 */                      \
            "movdqu %xmm3, -0xc0(%rbp)\n"  /* save xmm3 */                      \
            "movdqu %xmm4, -0xd0(%rbp)\n"  /* save xmm4 */                      \
            "movdqu %xmm5, -0xe0(%rbp)\n"  /* save xmm5 */                      \
            "movdqu %xmm6, -0xf0(%rbp)\n"  /* save xmm6 */                      \
            "movdqu %xmm7, -0x100(%rbp)\n" /* save xmm7 */                      \
                                                                                \
            /* Set up args for callback (they're already in regs) */            \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
                                                                                \
            /* Keep stack 16B aligned at call site: rbp-based frame is aligned */\
            "call " MH_STR(cb_fn) "\n"                                          \
                                                                                \
            /* Callback finished - discard its return value, restore original state */ \
                                                                                \
            /* Restore callee-saved registers */                                \
            "mov  -0x50(%rbp), %rbx\n"  /* restore rbx */                       \
            "mov  -0x58(%rbp), %r12\n"  /* restore r12 */                       \
            "mov  -0x60(%rbp), %r13\n"  /* restore r13 */                       \
            "mov  -0x68(%rbp), %r14\n"  /* restore r14 */                       \
            "mov  -0x70(%rbp), %r15\n"  /* restore r15 */                       \
            /* Restore ALL volatile registers exactly as caller passed them */  \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
            "mov  -0x28(%rbp), %r8\n"                                           \
            "mov  -0x30(%rbp), %r9\n"                                           \
            "mov  -0x38(%rbp), %r10\n"                                          \
            "mov  -0x40(%rbp), %r11\n"                                          \
            "mov  -0x48(%rbp), %rax\n"  /* restore rax (includes AL) */        \
            /* Restore XMM0-XMM7 registers */                                   \
            "movdqu -0x90(%rbp), %xmm0\n"                                       \
            "movdqu -0xa0(%rbp), %xmm1\n"                                       \
            "movdqu -0xb0(%rbp), %xmm2\n"                                       \
            "movdqu -0xc0(%rbp), %xmm3\n"                                       \
            "movdqu -0xd0(%rbp), %xmm4\n"                                       \
            "movdqu -0xe0(%rbp), %xmm5\n"                                       \
            "movdqu -0xf0(%rbp), %xmm6\n"                                       \
            "movdqu -0x100(%rbp), %xmm7\n"                                      \
            /* RAX now contains original value - DON'T overwrite with callback retval! */ \
                                                                                \
            /* Clean up stack frame, preserving rax */                          \
            "mov  %rbp, %rsp\n"  /* restore rsp */                             \
            "pop  %rbp\n"        /* restore rbp */                             \
                                                                                \
            /* Now push rax, load trampoline, swap, return via trampoline */    \
            "push %rax\n"  /* save return value on stack */                    \
            "lea " MH_STR(MH_TRAMP_SLOT(name)) "(%rip), %rax\n"                \
            "mov  (%rax), %rax\n"  /* load trampoline address */               \
            "xchg %rax, (%rsp)\n"  /* swap: rax gets return val, stack gets tramp */ \
            "ret\n"  /* "return" to trampoline with all regs restored */       \
        );                                                             \
    }
// ---- Extended thunk for functions with many arguments (up to 14) ----------
// Use this macro when your function has more than 6 arguments
#define MH_DEFINE_THUNK_LARGE(name, cb_fn)                            \
    __attribute__((used)) void *MH_TRAMP_SLOT(name) = 0;               \
    __attribute__((naked)) void MH_THUNK_LABEL(name)(void) {           \
        __asm__ volatile(                                              \
            /* Save frame and make space */                            \
            "push %rbp\n"                                               \
            "mov  %rsp, %rbp\n"                                        \
            "sub  $0x80, %rsp\n"  /* Space for saved regs + locals */  \
                                                                        \
            /* Save all argument registers */                          \
            "mov  %rdi, -0x08(%rbp)\n"  /* arg1 */                     \
            "mov  %rsi, -0x10(%rbp)\n"  /* arg2 */                     \
            "mov  %rdx, -0x18(%rbp)\n"  /* arg3 */                     \
            "mov  %rcx, -0x20(%rbp)\n"  /* arg4 */                     \
            "mov  %r8,  -0x28(%rbp)\n"  /* arg5 */                     \
            "mov  %r9,  -0x30(%rbp)\n"  /* arg6 */                     \
            "mov  %r10, -0x38(%rbp)\n"  /* r10 preserved */            \
            "mov  %r11, -0x40(%rbp)\n"  /* r11 preserved */            \
                                                                        \
            /* Stack args start at rbp+16 (after ret addr + saved rbp) */ \
            /* We need to copy them for the callback */                \
            /* Copy args 7-14 from original stack to new stack */      \
                                                                        \
            /* Push stack arguments in reverse order (14 to 7) */      \
            "mov  0x48(%rbp), %rax\n"  /* arg 14 */                    \
            "push %rax\n"                                               \
            "mov  0x40(%rbp), %rax\n"  /* arg 13 */                    \
            "push %rax\n"                                               \
            "mov  0x38(%rbp), %rax\n"  /* arg 12 */                    \
            "push %rax\n"                                               \
            "mov  0x30(%rbp), %rax\n"  /* arg 11 */                    \
            "push %rax\n"                                               \
            "mov  0x28(%rbp), %rax\n"  /* arg 10 */                    \
            "push %rax\n"                                               \
            "mov  0x20(%rbp), %rax\n"  /* arg 9 */                     \
            "push %rax\n"                                               \
            "mov  0x18(%rbp), %rax\n"  /* arg 8 */                     \
            "push %rax\n"                                               \
            "mov  0x10(%rbp), %rax\n"  /* arg 7 */                     \
            "push %rax\n"                                               \
                                                                        \
            /* Restore register args for callback */                   \
            "mov  -0x08(%rbp), %rdi\n"                                 \
            "mov  -0x10(%rbp), %rsi\n"                                 \
            "mov  -0x18(%rbp), %rdx\n"                                 \
            "mov  -0x20(%rbp), %rcx\n"                                 \
            "mov  -0x28(%rbp), %r8\n"                                  \
            "mov  -0x30(%rbp), %r9\n"                                  \
                                                                        \
            /* Call callback - it will see all 14 args */              \
            "call " MH_STR(cb_fn) "\n"                                 \
                                                                        \
            /* Clean up pushed stack args (8 * 8 bytes) */             \
            "add  $0x40, %rsp\n"                                        \
                                                                        \
            /* Restore all registers for original call */              \
            "mov  -0x08(%rbp), %rdi\n"                                 \
            "mov  -0x10(%rbp), %rsi\n"                                 \
            "mov  -0x18(%rbp), %rdx\n"                                 \
            "mov  -0x20(%rbp), %rcx\n"                                 \
            "mov  -0x28(%rbp), %r8\n"                                  \
            "mov  -0x30(%rbp), %r9\n"                                  \
            "mov  -0x38(%rbp), %r10\n"                                 \
            "mov  -0x40(%rbp), %r11\n"                                 \
                                                                        \
            /* Return to original via trampoline */                    \
            "leave\n"                                                   \
            "lea " MH_STR(MH_TRAMP_SLOT(name)) "(%rip), %rax\n"         \
             "jmp *(%rax)\n"                                            \
        );                                                             \
    }

// ---- Custom thunk for NewFromUtf8 with parameter modification support ------
// This thunk allows the callback to modify RSI and RCX by storing them in globals
static void* g_newfromutf8_modified_rsi = NULL;
static int64_t g_newfromutf8_modified_rcx = -1;

#define MH_DEFINE_THUNK_NEWFROMUTF8(name, cb_fn)                   \
    __attribute__((used)) void *MH_TRAMP_SLOT(name) = 0;               \
    __attribute__((naked)) void MH_THUNK_LABEL(name)(void) {           \
        __asm__ volatile(                                              \
            /* Prologue + spill volatile integer regs to stack */               \
            "push %rbp\n"                                                       \
            "mov  %rsp, %rbp\n"                                                 \
            "sub  $0x60, %rsp\n"                                                \
            "mov  %rdi, -0x08(%rbp)\n"  /* save rdi */                          \
            "mov  %rsi, -0x10(%rbp)\n"  /* save rsi */                          \
            "mov  %rdx, -0x18(%rbp)\n"  /* save rdx */                          \
            "mov  %rcx, -0x20(%rbp)\n"  /* save rcx */                          \
            "mov  %r8,  -0x28(%rbp)\n"  /* save r8  */                          \
            "mov  %r9,  -0x30(%rbp)\n"  /* save r9  */                          \
            "mov  %r10, -0x38(%rbp)\n"  /* save r10 */                          \
            "mov  %r11, -0x40(%rbp)\n"  /* save r11 */                          \
                                                                                \
            /* Set up args for callback */                                      \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
                                                                                \
            /* Call callback */                                                 \
            "call " MH_STR(cb_fn) "\n"                                          \
                                                                                \
            /* Save return value */                                             \
            "mov  %rax, -0x48(%rbp)\n"                                          \
                                                                                \
            /* Check if callback modified parameters via globals */             \
            "lea g_newfromutf8_modified_rsi(%rip), %rax\n"                      \
            "mov  (%rax), %rax\n"                                                \
            "test %rax, %rax\n"                                                  \
            "jz   1f\n"                  /* if NULL, skip modification */       \
                                                                                \
            /* Callback set modified RSI - use it instead of saved value */     \
            "mov  %rax, -0x10(%rbp)\n"   /* overwrite saved RSI */             \
                                                                                \
            /* Also check and apply modified RCX */                             \
            "lea g_newfromutf8_modified_rcx(%rip), %rax\n"                      \
            "mov  (%rax), %rax\n"                                                \
            "cmp  $-1, %rax\n"                                                   \
            "je   1f\n"                  /* if -1, skip modification */         \
            "mov  %rax, -0x20(%rbp)\n"   /* overwrite saved RCX */             \
                                                                                \
            "1:\n"                                                               \
            /* Restore all registers from (possibly modified) saved values */   \
            "mov  -0x08(%rbp), %rdi\n"                                          \
            "mov  -0x10(%rbp), %rsi\n"                                          \
            "mov  -0x18(%rbp), %rdx\n"                                          \
            "mov  -0x20(%rbp), %rcx\n"                                          \
            "mov  -0x28(%rbp), %r8\n"                                           \
            "mov  -0x30(%rbp), %r9\n"                                           \
            "mov  -0x38(%rbp), %r10\n"                                          \
            "mov  -0x40(%rbp), %r11\n"                                          \
                                                                                \
            /* Restore return value */                                          \
            "mov  -0x48(%rbp), %rax\n"                                          \
                                                                                \
            /* Clean up stack frame */                                          \
            "mov  %rbp, %rsp\n"                                                 \
            "pop  %rbp\n"                                                       \
                                                                                \
            /* Jump to trampoline with all regs restored */                     \
            "push %rax\n"                                                        \
            "lea " MH_STR(MH_TRAMP_SLOT(name)) "(%rip), %rax\n"                \
            "mov  (%rax), %rax\n"                                                \
            "xchg %rax, (%rsp)\n"                                                \
            "ret\n"                                                              \
        );                                                             \
    }

#else
#error "This thunk macro expects GCC/clang style inline asm."
#endif
